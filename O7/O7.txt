科目名: プログラミング実習III
課題: O7
番号: 37022503
氏名: 山形 隼士
作成: 2023/1/15

----------------------------------------
[課題7.1]
a[0]〜a[n-1] の値が一様に分布していると仮定する. まず, a[0]〜a[n-1] の最小値 min と最大値 max を求め, 区間 [min,max] を m 等分する. 次に, a[0]〜a[n-1] を, その値が何番目の区間に属するかにより, m 個のグループに分ける (このグループをバケツと呼ぶ). それぞれのグループをソートし, グループを区間の順に連結すれば, ソートが完了する.

B を定数とし, m = n/B とする. グループ分けにかかる時間は O(n) である. 各グループのソートに単純法を用いても時間は O(B2) で n に関しては定数なので, グループのソートと連結に要する時間は O(m) = O(n), 従って, 全体のソートにかかる時間は O(n) で済む.

グループの記憶方法は種々考えられる. 一手法としては, 下図のように区間の数だけ配列を割り当てる方法が考えられる. 即ち, i 番目の区間に属するデータは, b[i] が先頭要素を指す配列に格納する. b[i] の指す各配列は, 一旦 a[0]〜a[n-1] を走査してその区間に属するデータ数を数えてから, そのサイズの配列を動的に割り当てれば良い.

B は 8〜32 程度で試してみよ. 各グループのソートには単純選択法か単純挿入法を用いよ. (データ数が少ない場合には, クイックソートよりも単純法の方が高速なため.)

この方法に基づいて double 型配列 a の先頭 n 要素のソートを行う関数 void sort(int n, double *a) を作成し, bucket_sort.c に格納した. sort_test.c とリンクして動作確認した後, sort_cpu.c で計算時間を計測した.

実行結果は以下のとおりである。
gatahayato@Gatas-MacBook-Pro O7 % gcc -Wall sort_cpu.c bucket_sort.c
gatahayato@Gatas-MacBook-Pro O7 % ./a.out
乱数
       16807.00000
   282475249.00000
  1622650073.00000
   984943658.00000
  1144108930.00000
   470211272.00000
   101027544.00000
  1457850878.00000
nの値: 1024
cpu =    0.000049 [sec]
nの値: 2048
cpu =    0.000088 [sec]
nの値: 4096
cpu =    0.000175 [sec]
nの値: 8192
cpu =    0.000348 [sec]
nの値: 16384
cpu =    0.000694 [sec]
nの値: 32768
cpu =    0.001395 [sec]
nの値: 65536
cpu =    0.002637 [sec]
正順
           0.00000
           1.00000
           2.00000
           3.00000
           4.00000
           5.00000
           6.00000
           7.00000
nの値: 1024
cpu =    0.000024 [sec]
nの値: 2048
cpu =    0.000045 [sec]
nの値: 4096
cpu =    0.000087 [sec]
nの値: 8192
cpu =    0.000175 [sec]
nの値: 16384
cpu =    0.000351 [sec]
nの値: 32768
cpu =    0.000699 [sec]
nの値: 65536
cpu =    0.001393 [sec]
逆順
       65536.00000
       65535.00000
       65534.00000
       65533.00000
       65532.00000
       65531.00000
       65530.00000
       65529.00000
nの値: 1024
cpu =    0.000032 [sec]
nの値: 2048
cpu =    0.000059 [sec]
nの値: 4096
cpu =    0.000117 [sec]
nの値: 8192
cpu =    0.000233 [sec]
nの値: 16384
cpu =    0.000468 [sec]
nの値: 32768
cpu =    0.000926 [sec]
nの値: 65536
cpu =    0.001729 [sec]

問題の条件通り、バケットソートを用いてソーティングを行う関数を作成することができた。
バケットソートは、データ構造とアルゴリズムの授業において取り扱ったが、実際のコーディングは初めてであったため、時間がかかった。
問題の条件通りのことをコードに書き直していくことでうまく実装することができたが、グループの記憶方法を探すのに時間が特にかかった。

----------------------------------------
[課題7.2]
バケツソートにおいて, 区間毎に配列を割り当てるのではなく, a と同じサイズ n の配列 b を 1 つ割り当て, 下図のように b の先頭から順に区間0, 区間1, …, 区間 m-1 のデータを格納する方法がある.


「区間 i のデータを b のどこに格納すれば良いか」が問題になるが, これは, 区間数をサイズとする整数配列 c と d を用いて決定する. まず, 配列 a を走査し, 各区間のデータ数を c に記録する (区間 i のデータ数を c[i] に記録する; 上の図の中央). 次に, d[0]=0, d[i+1]=d[i]+c[i] という漸化式に基づいて d を計算する. すると, d[i] は 区間 i のデータの b 内での先頭位置を表わす.

i=0 から n-1 について,

a[i] が区間 k に属するとき, a[i] を b[d[k]] にコピーし,
d[k] を 1 増やす
という操作を繰り返せば, 上図の b のようにデータを格納することができる.
最後に, 配列 b を配列 a にコピーして, 単純挿入法で a をソートすれば, データ全体のソートが完了する. 単純挿入法は「だいたい整列されいているデータ」のソートには非常に高速であり, B の値 (バケツのサイズ; 各区間のデータ数の上限) が定数であれば, n 要素のソートが O(n) で行える.

この方法に基づいて double 型配列 a の先頭 n 要素のソートを行う関数 void sort(int n, double *a) を作成し, dc_sort.c に格納せよ. sort_test.c とリンクして動作確認した後, sort_cpu.c で計算時間を計測した。

実行結果は以下のとおりである。
gatahayato@Gatas-MacBook-Pro O7 % gcc -Wall dc_sort.c sort_cpu.c 
gatahayato@Gatas-MacBook-Pro O7 % ./a.out
乱数
       16807.00000
   282475249.00000
  1622650073.00000
   984943658.00000
  1144108930.00000
   470211272.00000
   101027544.00000
  1457850878.00000
nの値: 1024
cpu =    0.000086 [sec]
nの値: 2048
cpu =    0.000161 [sec]
nの値: 4096
cpu =    0.000317 [sec]
nの値: 8192
cpu =    0.000636 [sec]
nの値: 16384
cpu =    0.001275 [sec]
nの値: 32768
cpu =    0.002540 [sec]
nの値: 65536
cpu =    0.004623 [sec]
正順
           0.00000
           1.00000
           2.00000
           3.00000
           4.00000
           5.00000
           6.00000
           7.00000
nの値: 1024
cpu =    0.000052 [sec]
nの値: 2048
cpu =    0.000061 [sec]
nの値: 4096
cpu =    0.000120 [sec]
nの値: 8192
cpu =    0.000239 [sec]
nの値: 16384
cpu =    0.000513 [sec]
nの値: 32768
cpu =    0.001027 [sec]
nの値: 65536
cpu =    0.001872 [sec]
逆順
       65536.00000
       65535.00000
       65534.00000
       65533.00000
       65532.00000
       65531.00000
       65530.00000
       65529.00000
nの値: 1024
cpu =    0.000056 [sec]
nの値: 2048
cpu =    0.000094 [sec]
nの値: 4096
cpu =    0.000187 [sec]
nの値: 8192
cpu =    0.000372 [sec]
nの値: 16384
cpu =    0.000727 [sec]
nの値: 32768
cpu =    0.001210 [sec]
nの値: 65536
cpu =    0.002428 [sec]

バケットソートにおいて、また違ったデータ構造を持つソートを作成することができた。
具体的には、問題の条件通り、区間iのデータ数を配列cに格納し、出発地点を配列dに格納することで、問題の条件通りのデータ構造にすることができた。
また、その後にi=0から、n-1まで処理を行うことで、ソーティングすることができた。
また、実行結果よりも明らかであるが、バケットソートは非常に高速なアルゴリズムであるということわかる。

----------------------------------------
[課題 O7 の感想]
今回の課題では、ソーティング(バケットソート)を勉強することができた。
今までソーティングぉするアルゴリズムは単純挿入法の様な様々なものを勉強したが、バケットソートをメインでコーディングしたことがなかったため、
苦戦してしまった。しかし、このアルゴリズムは、ある程度並んでいるデータに対しては非常に強力であるということがわかったため、ソーティングの時には
クイックソート等と使い分けて使っていきたい。