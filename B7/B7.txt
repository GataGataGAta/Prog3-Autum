科目名: プログラミング実習III
課題: B7
番号: 37022503
氏名: 山形 隼士
作成: 2023/11/14

----------------------------------------
[課題7.1]
double 型の配列 a とその サイズ n, および整数 k (0≤k<n) が与えられたときに, 次の処理を行う関数 void swapmin(int n, double *a, int k) を作成した.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B7 % gcc -Wall swapmin.c swapmin_test.c    
gatahayato@Gatas-MacBook-Pro B7 % ./a.out
n = 5
[0] : 6
[1] : 2
[2] : 4
[3] : 9
[4] : 8
[0]    6.00000
[1]    2.00000
[2]    4.00000
[3]    9.00000
[4]    8.00000
k = 0
swapmin(n, a, 0)
[0]    2.00000
[1]    6.00000
[2]    4.00000
[3]    9.00000
[4]    8.00000
k = 1
swapmin(n, a, 1)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 2
swapmin(n, a, 2)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 3
swapmin(n, a, 3)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    8.00000
[4]    9.00000

最小値a[i]とa[k]の値を入れ替える関数を作成することができた。
初めは最小値の初期値をa[0]としていたが、それでは２回目以降のループで値が入れ替わらないため
初期値を十分大きな値に設定した。また、値の入れ替えはtmpを用いた。

----------------------------------------
[課題7.2]
単純選択法により a[0]〜a[n-1] のソートを行う関数 void sort(int n, double *a) を作成し, selection_sort.c に格納した.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B7 % gcc -Wall sort_test.c selection_sort.c
gatahayato@Gatas-MacBook-Pro B7 % ./a.out < in.txt > out.txt
n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : 
[3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : 
[2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0]
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0]
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : [1] : [2] : [3] : n = [0] : 
[1] : [2] : [3] : [4] : [5] : [6] : [7] : [8] : [9] : [10] : [11] : [12] : [13] : 
[14] : [15] : n = [0] : [1] : [2] : [3] : [4] : [5] : [6] : [7] : [8] : [9] : [10] :
[11] : [12] : [13] : [14] : [15] : n = [0] : [1] : [2] : [3] : [4] : [5] : [6] : [7] :
[8] : [9] : [10] : [11] : [12] : [13] : [14] : [15] : n = %                                            
gatahayato@Gatas-MacBook-Pro B7 % diff -Bw exp.txt out.txt

out.txtの内容は以下の通りである
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 -0.1
 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6
 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6
 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6

単純選択法により、a[0]~a[n-1]を昇順に並べ替える関数を作成した。
(1)の関数を利用することによってうまく並び替えることができた。
特に苦戦することはなかった。

----------------------------------------
[課題7.3]
double 型の配列 a とその サイズ n, および整数 k (1≤k<n) が与えられたときに, 次の処理を行う関数 void insert(int n, double *a, int k) を作成した.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B7 % gcc -Wall insert.c insert_test.c
gatahayato@Gatas-MacBook-Pro B7 % ./a.out
n = 5
[0] : 6
[1] : 2
[2] : 4
[3] : 9
[4] : 8
[0]    6.00000
[1]    2.00000
[2]    4.00000
[3]    9.00000
[4]    8.00000
k = 1
insert(n, a, 1)
[0]    2.00000
[1]    6.00000
[2]    4.00000
[3]    9.00000
[4]    8.00000
k = 2
insert(n, a, 2)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 3
insert(n, a, 3)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 4
insert(n, a, 4)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    8.00000
[4]    9.00000
k = %    

問題文に記されていたforループを参考に、条件を0 <= iとすることでソートをする関数を作成した。
また、forループの中でif(a[i-1] <= a[i])の時はbreakし、それ以外の時に限りa[i]とa[i-1]の値を交換した。

----------------------------------------
[課題7.4]
単純挿入法により a[0]〜a[n-1] のソートを行う関数 void sort(int n, double *a) をファイル insertion_sort.c に作成せよ.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B7 % gcc -Wall insertion_sort.c sort_test.c
gatahayato@Gatas-MacBook-Pro B7 % ./a.out
n = 5
[0] : 4
[1] : 6
[2] : 2
[3] : 8
[4] : 1
 1.0 2.0 4.0 6.0 8.0
n = %           

課題(2)と同様に、for(k=1; k<=n-1; k++)の中に課題(3)を入れることで、ソートをする関数を作成することができた。
特に苦戦することはなかったが、forループの条件を書き間違えてしまっていた。しっかりとループの回数を吟味していきたい。

----------------------------------------
[課題7.5]
次は, ソートの計算に要する時間を計測するプログラム sort_cpu.c の原型 (未完成) である. 下記の指示に従ってプログラムを完成させた.

実行結果は以下の通りである。
乱数
       16807.00000
   282475249.00000
  1622650073.00000
   984943658.00000
  1144108930.00000
   470211272.00000
   101027544.00000
  1457850878.00000
nの値: 2
cpu =    0.000004 [sec]
nの値: 4
cpu =    0.000001 [sec]
nの値: 8
cpu =    0.000001 [sec]
正順
           0.00000
           1.00000
           2.00000
           3.00000
           4.00000
           5.00000
           6.00000
           7.00000
nの値: 2
cpu =    0.000002 [sec]
nの値: 4
cpu =    0.000002 [sec]
nの値: 8
cpu =    0.000002 [sec]
逆順
           8.00000
           7.00000
           6.00000
           5.00000
           4.00000
           3.00000
           2.00000
           1.00000
nの値: 2
cpu =    0.000000 [sec]
nの値: 4
cpu =    0.000000 [sec]
nの値: 8
cpu =    0.000002 [sec]

変更後
乱数
       16807.00000
   282475249.00000
  1622650073.00000
   984943658.00000
  1144108930.00000
   470211272.00000
   101027544.00000
  1457850878.00000
nの値: 1024
cpu =    0.002329 [sec]
nの値: 2048
cpu =    0.008059 [sec]
nの値: 4096
cpu =    0.022837 [sec]
nの値: 8192
cpu =    0.052030 [sec]
nの値: 16384
cpu =    0.158724 [sec]
nの値: 32768
cpu =    0.634668 [sec]
nの値: 65536
cpu =    2.491840 [sec]
正順
           0.00000
           1.00000
           2.00000
           3.00000
           4.00000
           5.00000
           6.00000
           7.00000
nの値: 1024
cpu =    0.000631 [sec]
nの値: 2048
cpu =    0.002443 [sec]
nの値: 4096
cpu =    0.009873 [sec]
nの値: 8192
cpu =    0.038825 [sec]
nの値: 16384
cpu =    0.163855 [sec]
nの値: 32768
cpu =    0.618333 [sec]
nの値: 65536
cpu =    2.470458 [sec]
逆順
       65536.00000
       65535.00000
       65534.00000
       65533.00000
       65532.00000
       65531.00000
       65530.00000
       65529.00000
nの値: 1024
cpu =    0.000717 [sec]
nの値: 2048
cpu =    0.002748 [sec]
nの値: 4096
cpu =    0.011192 [sec]
nの値: 8192
cpu =    0.043733 [sec]
nの値: 16384
cpu =    0.175585 [sec]
nの値: 32768
cpu =    0.694368 [sec]
nの値: 65536
cpu =    2.781565 [sec]

最適化
乱数
       16807.00000
   282475249.00000
  1622650073.00000
   984943658.00000
  1144108930.00000
   470211272.00000
   101027544.00000
  1457850878.00000
nの値: 1024
cpu =    0.001184 [sec]
nの値: 2048
cpu =    0.004444 [sec]
nの値: 4096
cpu =    0.018789 [sec]
nの値: 8192
cpu =    0.052545 [sec]
nの値: 16384
cpu =    0.154824 [sec]
nの値: 32768
cpu =    0.625979 [sec]
nの値: 65536
cpu =    2.477825 [sec]
正順
           0.00000
           1.00000
           2.00000
           3.00000
           4.00000
           5.00000
           6.00000
           7.00000
nの値: 1024
cpu =    0.000586 [sec]
nの値: 2048
cpu =    0.002375 [sec]
nの値: 4096
cpu =    0.009562 [sec]
nの値: 8192
cpu =    0.038458 [sec]
nの値: 16384
cpu =    0.153667 [sec]
nの値: 32768
cpu =    0.615416 [sec]
nの値: 65536
cpu =    2.471523 [sec]
逆順
       65536.00000
       65535.00000
       65534.00000
       65533.00000
       65532.00000
       65531.00000
       65530.00000
       65529.00000
nの値: 1024
cpu =    0.000589 [sec]
nの値: 2048
cpu =    0.002337 [sec]
nの値: 4096
cpu =    0.009722 [sec]
nの値: 8192
cpu =    0.038435 [sec]
nの値: 16384
cpu =    0.153497 [sec]
nの値: 32768
cpu =    0.614850 [sec]
nの値: 65536
cpu =    2.470319 [sec]

単純挿入法
乱数
       16807.00000
   282475249.00000
  1622650073.00000
   984943658.00000
  1144108930.00000
   470211272.00000
   101027544.00000
  1457850878.00000
nの値: 1024
cpu =    0.003875 [sec]
nの値: 2048
cpu =    0.012514 [sec]
nの値: 4096
cpu =    0.033167 [sec]
nの値: 8192
cpu =    0.090284 [sec]
nの値: 16384
cpu =    0.336160 [sec]
nの値: 32768
cpu =    1.350129 [sec]
nの値: 65536
cpu =    5.350003 [sec]
正順
           0.00000
           1.00000
           2.00000
           3.00000
           4.00000
           5.00000
           6.00000
           7.00000
nの値: 1024
cpu =    0.000781 [sec]
nの値: 2048
cpu =    0.003030 [sec]
nの値: 4096
cpu =    0.012203 [sec]
nの値: 8192
cpu =    0.048704 [sec]
nの値: 16384
cpu =    0.193101 [sec]
nの値: 32768
cpu =    0.771303 [sec]
nの値: 65536
cpu =    3.083943 [sec]
逆順
       65536.00000
       65535.00000
       65534.00000
       65533.00000
       65532.00000
       65531.00000
       65530.00000
       65529.00000
nの値: 1024
cpu =    0.001880 [sec]
nの値: 2048
cpu =    0.007755 [sec]
nの値: 4096
cpu =    0.030019 [sec]
nの値: 8192
cpu =    0.118903 [sec]
nの値: 16384
cpu =    0.474453 [sec]
nの値: 32768
cpu =    1.913019 [sec]
nの値: 65536
cpu =    7.630215 [sec]

以下の三つの事柄について、レポートに記す。
最適化を行なわない場合と行なった場合で, 実行時間がどの程度異なるか.
→最適化を行おうと、乱数の数が小さい場合はあまり実行結果の時間を短くすることができていないが、乱数の数が多い場合は、実行する時間が早くなっている。

最適を行った場合について, 初期データが乱数, 正順, 逆順の場合の計算時間はどのように異なるか.
→最適化を行った場合、乱数の計算時間は、正順、逆順に比べて多いことがわかる。しかし、ソートする数字の数が多い場合は、あまり差は出ない。

最適を行った場合について, n の増加に対して計算時間はどのような割合で増えているか. レポートに記せ.
→nが2倍になると、計算時間は約4倍ほどに増加している。

----------------------------------------
[課題7.6]
クイックソートにより配列 a の先頭から n 個のデータのソートを行う関数 void sort(int n, double *a) を昇順に並べ替える関数を作成した。

実行結果は以下の通りである。
atahayato@Gatas-MacBook-Pro B7 % gcc -Wall quick_sort.c sort_test.c
gatahayato@Gatas-MacBook-Pro B7 % ./a.out                           
n = 5
[0] : 4 
[1] : 5
[2] : 2
[3] : 67
[4] : 3
 2.0 3.0 4.0 5.0 67.0
n = %          

sort_cpuとリンクした結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B7 % ./a.out
乱数
       16807.00000
   282475249.00000
  1622650073.00000
   984943658.00000
  1144108930.00000
   470211272.00000
   101027544.00000
  1457850878.00000
nの値: 1024
cpu =    0.000170 [sec]
nの値: 2048
cpu =    0.000345 [sec]
nの値: 4096
cpu =    0.000754 [sec]
nの値: 8192
cpu =    0.001587 [sec]
nの値: 16384
cpu =    0.003158 [sec]
nの値: 32768
cpu =    0.007335 [sec]
nの値: 65536
cpu =    0.013600 [sec]
正順
           0.00000
           1.00000
           2.00000
           3.00000
           4.00000
           5.00000
           6.00000
           7.00000
nの値: 1024
cpu =    0.000671 [sec]
nの値: 2048
cpu =    0.002401 [sec]
nの値: 4096
cpu =    0.008503 [sec]
nの値: 8192
cpu =    0.027051 [sec]
nの値: 16384
cpu =    0.082914 [sec]
nの値: 32768
cpu =    0.322292 [sec]
nの値: 65536
cpu =    1.302463 [sec]
逆順
       65536.00000
       65535.00000
       65534.00000
       65533.00000
       65532.00000
       65531.00000
       65530.00000
       65529.00000
nの値: 1024
cpu =    0.000351 [sec]
nの値: 2048
cpu =    0.001269 [sec]
nの値: 4096
cpu =    0.005261 [sec]
nの値: 8192
cpu =    0.019908 [sec]
nの値: 16384
cpu =    0.079478 [sec]
nの値: 32768
cpu =    0.322860 [sec]
nの値: 65536
cpu =    1.295000 [sec]

クイックソートを実行する関数を作成した。クイックソートを利用すると、単純選択法、単純挿入法に比べかなり高速でソートすることができた。
データ構造とアルゴリズムの授業ではただ、クイックソートが高速であるということしか勉強しなかったが、実際に自分の目で見て実感することができた。

----------------------------------------
[課題7.7]
下記の指示に従って, 課題 (7-2) の単純選択法または課題 (7-4) の単純挿入法 (自分が理解しやすい方を選べ) の void sort(int n, double *a) を書き換え, 
文字列 (文字配列) の配列をソートする void string_sort(int n, char (*a)[STRLEN+1]) を string_sort.c に作成した.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B7 % gcc -Wall string_sort.c test.c
gatahayato@Gatas-MacBook-Pro B7 % ./a.out < in2.txt > out.
n = [0] : [1] : [2] : [3] : [4] : %                                                                                                                                
gatahayato@Gatas-MacBook-Pro B7 % diff -Bw out.txt exp2.txt

out.txtの内容は以下の通りである
nakamura
suzuki
tanaka
yamada
yamamoto

入力された文字列を逆順に出力する関数を作成することができた。問題文の内容の通りに書き換えることで、
うまく逆順で出力することができた。

----------------------------------------
[課題7.8]
下記の指示に従って, 課題 (7_2) の単純選択法の void sort(int n, double *a) を書き換え, 次のように定義された構造体の配列を,
構造体中の age の昇順に, ただし age が等しいものは height の昇順にソートする関数 void str_sort(int n, record_t *a) を作成せよ.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B7 % gcc -Wall str_sort.c str_sort_test.c
gatahayato@Gatas-MacBook-Pro B7 % ./a.out < in3.txt > out.txt         
n = [0].name : [0].age : [0].height : 
[1].name : [1].age : [1].height : 
[2].name : [2].age : [2].height : 
[3].name : [3].age : [3].height : 
[4].name : [4].age : [4].height : 
[5].name : [5].age : [5].height : %                                                                                                                     
gatahayato@Gatas-MacBook-Pro B7 % diff -Bw out.txt exp3.txt

out.txtの内容は以下の通りである
tanaka     20 170.00
suzuki     21 165.30
nakamura   21 175.30
yamada     22 160.50
yamamoto   22 177.40
nakamura   22 179.70

名前と年齢、身長の値を入力しそれを逆順で出力する関数を作成した。
この課題も前回と同じく、問題文の条件に従って関数を修正することで、うまく動作させることができた。

----------------------------------------
[課題 B7 の感想]
今回の課題では、ソーティングについて勉強することができた。いくつかのソーティング法については、すでに他の授業で勉強していたが、
実際に実行したことがなかったため、今回の課題を勉強することでそれぞれのソーティング法がどのように実行されているのかを勉強することができた。
２回目の中間テストが迫ってきているため、しっかりと復習しながら勉強していきたい。