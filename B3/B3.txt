科目名: プログラミング実習III
課題: B1
番号: 37022503
氏名: 山形 隼士
作成: 2023年10月10日

----------------------------------------

[課題 3.1]
int 型の変数 a, b と double 型の変数 x, y を宣言し, それぞれの番地を表示するプログラム pointer1.c を作成した. 

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % gcc -Wall pointer.c 
gatahayato@Gatas-MacBook-Pro B3 % ./a.out
 a のの番地は0x16dc7f208です。
 b のの番地は0x16dc7f204です。
 x のの番地は0x16dc7f1f8です。
 y のの番地は0x16dc7f1f0です。

問題の条件通り変数のアドレスを表示することができた　　　　　　　　
int型のa,bでは4バイトづつ、double型のx, yでは8バイトづつ値が変化していた。

----------------------------------------

[課題 3.2]

課題 (3-1) の pointer1.c と同様に int 型の変数 a, b と double 型の変数 x, y を宣言して番地を表示し, 
その番地を用いて変数 a, b, x, y の値を書き換え, a, b, x, y の値を表示するプログラム pointer2.c を作成した.

実行結果は以下の通りである。
$ ./a
aの番地: 0x7ffffcc2c
bの番地: 0x7ffffcc28
xの番地: 0x7ffffcc20
yの番地: 0x7ffffcc18


a の値 = 24
b の値 = 56
x の値 = 16.000000
y の値 = 23.000000

問題の条件通り、番地を使って変数の中身を書き換えることができた。
コードの中にも記述したが、私が使っているPCの環境ではアドレスが実行するたびに書き変わってしまうので
学校のPCを用いて作成しました。問題なく動作してくてくれましたが、久しぶりのWindowsだったため、
少し苦戦しました。テストに向けてまた思い出すようにしていきます。

----------------------------------------

[課題 3.3]
次のようなプログラム pointer3.c を作成した.

課題 (3-1) の pointer1.c と同様に int 型の変数 a, b と double 型の変数 x, y を宣言する.
int 型ポインタ変数と double 型ポインタ変数を宣言する.
変数 a, b, x, y の番地を表示する.
ポインタ変数を用いて, b の値に 4 を足し, x の値を 2 倍する.
double 型変数 (x と y) の番地を入力し, その番地に格納されている値を表示する (番地 0 が入力されるまで繰り返す).

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % gcc -Wall pointer3.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out             
 a のの番地は0x16ce4b208です。
 b のの番地は0x16ce4b204です。
 x のの番地は0x16ce4b1f8です。
 y のの番地は0x16ce4b1f0です。
番地を入力 : 0x16ce4b1f8 0x16ce4b1f0
0x16ce4b1f8 番地の内容は 2.000000
0x16ce4b1f0 番地の内容は 4.000000
番地を入力 : 0 0

問題の条件通り、ポインタ変数を用いて変数の中身を書き換えることができた。
入力をする部分で少し苦戦してしまった。scanfを使用したのだが、
入力された値を%pで取ることでうまく動かすことができた。
また、int型のポインタ変数であるpを使って何度かdouble型の変数にアクセスしてしまった。
変数と、ポインタ変数の型には気を配っていきたい。

----------------------------------------

[課題 3.4]

int 型変数 x と y, および int 型へのポインタ変数 q, r を受け取り,
x を y で割った商を q 番地の変数に, 剰余を r 番地の変数に格納して返す関数 divrem を作成した.

下記のプログラムの空欄を埋め, 完成したプログラムを divrem.c として提出する.

#include <stdio.h>

void divrem(int x, int y, int *q, int *r)
{
  /* この関数の本体を完成させよ */
}

int main(void)
{
  int x = 10, y = 3;
  int q, r;
  divrem( /* ここを埋めて, x を y で割った商と剰余が q と r に格納されるようにせよ */ );
  printf("x / y = %d ... %d\n", q, r);
  return 0;
}

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % gcc -Wall divrem.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out 
x / y = 3 ... 1

xをyで割った商と剰余がqとrに格納されるような関数を作成することができた。
プログラミング実習2で勉強したように、複数の返り値を持つ関数を作成するときには
ポインタを活用すれば良いと再確認できた。また、qにはx/y、rにはx%rを計算した値を入れることで
うまく計算させることができた。

----------------------------------------

[課題 3.5]

double 型の値 a と b, double 型へのポインタ p_a, p_m を受け取り, a と b の相加平均を p_a 番地に, 
相乗平均を p_m 番地に格納する関数 void ave(double a, double b, double *p_a, double *p_m) を作成した。
関数 ave は ave6.c というファイルに格納し、関数 ave のプロトタイプ宣言を格納した下記の ave6.h をインクルードした. 
下記の ave6main.c と ave6.c をリンクして実行し, 動作を確認した.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % gcc ave6.c ave6main.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out < ave-in.txt > out.txt
2つの実数 a, b を入力して下さい: 2つの実数 a, b を入力して下さい: 
2つの実数 a, b を入力して下さい: 2つの実数 a, b を入力して下さい:
gatahayato@Gatas-MacBook-Pro B3 % diff -w out.txt ave-exp.txt

out.txtの内容は以下の通りである。
1.500 1.414
3.500 3.464
5.500 5.477

問題の条件通り、相加平均と相乗平均を返す関数を作成することができた。
相加平均には(a + b) / 2;、相乗平均にはsqrt(a * b);の値をそれぞれ計算することで
うまくお互いの値を計算することができた。分割コンパイルにも慣れてきているので、
テストまでにしっかりと使いこなせるようになっていきたい

----------------------------------------

[課題 3.6]

課題 (2-4) で作成した qeq2.c を次のように書き換え, qeq3.c を作成した.

関数を int qeq(double a, double b, double c, double *x1, double *x2) とする. 
関数 qeq の中で解を出力するのではなく, 解の個数を返り値として返し, 解を *x1 と *x2 にセットするようにした.
解が 1 つの場合は, *x1 にその解をセットせよ. 解が 2 つの場合は, 小さい方を *x1 に, もう一方を *x2 にセットするようにせよ.
ヘッダファイル次の qeq3.h をインクルードするようにせよ. 次の qeq3main.c とリンクして動作を確認せよ. プログラムは qeq3.c のみ提出した.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % diff -w out.txt ave-exp.txt
gatahayato@Gatas-MacBook-Pro B3 % gcc qeq3.c qeq3main.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out < qeq-in.txt > out.txt
gatahayato@Gatas-MacBook-Pro B3 % diff -w out.txt qeq-exp.txt

out.txtの内容は以下の通りである。
-2.00000 -1.00000
-1.00000

-4.13746 -0.36254
-0.74568 2.14568
1.00000
0.37417 3.05440
0.81386 3.68614

課題(2-4)で作成したコードをもとに、問題の条件に合うようにコードを作成することができた。
(2-4)では関数内で答えを出力していたが、解を返り値に設定することで、main関数内で解を出力することができた。
特に苦戦することはなかったので、ポインタを使った関数にどんどん慣れていきたい。

----------------------------------------

[課題 3.7]

課題 (2-3) と同様の構造体型

typedef struct {
  double x;   /* x座標 */
  double y;   /* y座標 */
} point_t;

が定義されているとする. 
下記の 2 つの関数を作成し, ファイル dist5.c に格納した.
int point_scan(point_t *p)
p の指す point_t 型変数のメンバー x と y に標準入力から実数値を読み込む.
標準入力が EOF の場合には EOF を, そうでない場合は 1 を返す.
double dist(point_t *p1, point_t *p2)
2点 *p1 と *p2 の間の距離を返す.
dist5.c からは次の dist5.h (および標準ヘッダ stdio.h, math.h) をインクルードすること.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % gcc dist5.c dist5main.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out < dist-in.txt > out.txt
gatahayato@Gatas-MacBook-Pro B3 % diff -w out.txt dist-exp.txt

out.txtの内容は以下の通りである。
1.4142
5.8310
3.1396

問題の条件通り、構造体に標準入力から値を読み込み、二つの構造体の距離を求めることができた。
構造体に値を入力する際に少し苦戦してしまった。結果的にscnf("%lf %lf", &(p->x), &(p->y))と書くことで
うまく実装することができた。構造体とポインタのコンビネーションにまだ慣れていないため、
テストに向けて、しっかりと復習しておきたい。

----------------------------------------

[課題 3.8]

下記 1 〜 6 を行うプログラム arrayp.c を作成した.

まず, 次のような int 型の配列 x[ ] を宣言する．
int x[ ] = {0,10,20,30,40};
/* x[0]=0, x[1]=10, x[2]=20, x[3]=30, x[4]=40 と初期化される */

教科書 p. 382 を参考に, sizeof 演算子を用いて配列 x[ ] の要素数を求めて k に代入し, それを出力せよ.

x[0], x[1], …, x[k-1] のアドレスを出力せよ (printf の書式指定には %p を用いよ). アドレスがいくつづつ増えているかレポートに記せ.

x の値 (アドレス) を表示せよ (printf の書式指定には %p を用いよ). 2 で表示したアドレスのいずれと一致するかレポートに記せ.

x+0, x+1, …, x+k-1 の値 (アドレス) を表示せよ. 2 で表示したアドレスのいずれと一致するかレポートに記せ.

アドレス x+0, x+1, …, x+k-1 に格納されているデータの値を表示せよ. x[0], x[1], …, x[k-1] のいずれの値と一致するかレポートに記せ.

int 型を指すポインタ変数 p を宣言し, p に x[2] のアドレスを代入せよ. このとき，p+2 の値 (アドレス) と p[2] の値を表示せよ. 
また、なぜそのような値になるのかを考察し, 結果をレポートに記せ．

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % gcc -Wall arrayp.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out           
k = 5
x[0]のアドレスは0x16d88f1f0です。
x[1]のアドレスは0x16d88f1f4です。
x[2]のアドレスは0x16d88f1f8です。
x[3]のアドレスは0x16d88f1fcです。
x[4]のアドレスは0x16d88f200です。

xのアドレスは0x16d88f1f0です。

x + 0のアドレスは0x16d88f1f0です。
x + 1のアドレスは0x16d88f1f4です。
x + 2のアドレスは0x16d88f1f8です。
x + 3のアドレスは0x16d88f1fcです。
x + 4のアドレスは0x16d88f200です。

x + 0の値は0です。
x + 1の値は10です。
x + 2の値は20です。
x + 3の値は30です。
x + 4の値は40です。

p + 2の値は0x16d88f200です。
p[2]の値は40です。

以下、問題に答えていく。
2. x[0], x[1], …, x[k-1] のアドレスは4ずつ増加している。これは、配列xがint型であるからである。
3. xのアドレスは、配列xの先頭の要素、つまりx[1]のアドレスと一致している。
4. x+1, x+2...のアドレスは、x[]のアドレスと一致している。
5. x+k-1の値は、それぞれx[k-1]の値と一致している。
6. p+2のアドレスはx[4]のアドレスと一致しており、値も同様に一致している、これはpにx[2]のアドレスを代入したからである。

----------------------------------------

[課題 3.9]
下記の 2 つの関数を作成し, ファイル ave_max.c に格納した.

int array_scan(int a[ ])
int 型配列 a[ ] に標準入力からデータを読み込み (EOF で終了判定する; 最大のデータ数は MAX 個とする), その 要素数を返す.
void array_ave_max(int n, int a[ ], double *ave, int *max)
配列 a[ ] とサイズ n を受け取り, a[0]〜a[n-1] の平均値と最大値をそれぞれ *ave, *max に格納する.
ave_max.c からは次の ave_max.h (および標準ヘッダ stdio.h) をインクルードすること.

実行結果は以下の通りである。
gatahayato@Gatas-MacBook-Pro B3 % gcc -Wall ave_max.c ave_max_main.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out < ave_max_in.txt > out.txt
gatahayato@Gatas-MacBook-Pro B3 % diff -w out.txt  max-exp.txt

out.txtの内容は以下の通りである。
1個目: 5.500 10
2個目: -12.500 -6

入力する部分ではwhileループを用い、入力するデータがEOFになるまで変数をインクリメントすることで
配列の長さを求めることができた。また、代償比較の部分ではmaxにa[0]の値を入力し、その値よりも大きな値が存在した場合
その値をmaxに代入することで一番大きなものを取り出すことができた。ポインタ変数を使った代償比較は初めてだったため、
しっかりと復習して、テストに備えておきたい。

----------------------------------------

[課題 3.10]

3個のサイコロを n 回振ったときに出た目の和がどのような分布になっているか, を調べるプログラム dice3.c を作成した. 
このプログラムに必要になる下記の 2 つの関数を作成し, ファイル dice3sub.c に格納した.

void dice_throw(int d[ ], int n)
1〜6 の整数の一様乱数を n 個発生し, d[0]〜d[n-1] に格納する.
void dice3_distr(int n, int d1[ ], int d2[ ], int d3[ ], int c[ ])
d1[0]〜d1[n-1] は 1 個目のサイコロを n 回振ったときに出た目を記録したものであり, 
d2[0]〜d2[n-1] は 2 個目のサイコロを n 回振ったときに出た目を記録したものであり, 
d3[0]〜d3[n-1] は 3 個目のサイコロを n 回振ったときに出た目を記録したものとする. 
この関数は, n, d1[ ], d2[ ], d3[ ] を受け取り, d1[i] と d2[i] と d3[i] の和 s が出現した回数を c[s] にカウントする.
dice3sub.c からは次の dice3sub.h (および必要な標準ヘッダ) をインクルードすること.

実行結果は以下の通りである。
atahayato@Gatas-MacBook-Pro B3 % gcc -Wall dice3.c dice3sub.c
gatahayato@Gatas-MacBook-Pro B3 % ./a.out                     
サイコロを振る回数 n = 100
 3:      4
 4:      8
 5:     14
 6:     12
 7:     12
 8:      8
 9:     13
10:     10
11:      5
12:      5
13:      2
14:      3
15:      0
16:      0
17:      1
18:      0

サイコロをn回降った時のでた目の和がどのような分布になっているのかを調べる関数を作成することができた。
乱数を使用するために、自作関数のirand関数を利用した。また、jを定義し、jに三つのサイコロの和を代入し、
c[j]をインクリメントすることで分布を求めることができた。

----------------------------------------

[課題 B3 の感想]
今回の課題では、主にポインタについて復習した。ポインタは配列や構造体とも関係していることは知っていたが、
具体的にそれらを絡めたプログラムは作ったことがなかったため、今回の課題は非常に難しく感じた。また、ポインタのアドレスについても
かなり忘れてしまっていたため、プログラミング実習2の教科書を参照して復習しながらテストに備えていきたい。