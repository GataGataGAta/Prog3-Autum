科目名: プログラミング実習III
課題: O4
番号: 37022503
氏名: 山形 隼士
作成: 2023/1/15

----------------------------------------
[課題4.1]
下記の jordan.c は, Gauss-Jordan 法により n 元連立一次方程式を解くプログラムである． これまでに作成した matrix.c に次の関数の本体を追加し, 
jordan.c と matrix.c をリンクして正しく計算が行われるようにせよ. 関数を追加した matrix.c を提出した.
void matrix_copy(int n, double From[N][N], double To[N][N])
n×n 行列のデータを From から To にコピーする.
void vector_copy(int n, double from[N], double to[N])
n 次元ベクトルのデータを from から to にコピーする.
void matrix_vector_print(int n, double A[N][N], double b[N])
配列 A に格納された n×n 行列のデータと, 配列 b に格納された n 次元ベクトルを, 下記のように横に並べて出力する.
　　		2	4	6			16
例えば　　A	=	3	8	7	, 　　x	=	15　　であれば,
　　		5	7	2			24
   2.00000   4.00000   6.00000 :   16.00000
   3.00000   8.00000   7.00000 :   15.00000
   5.00000   7.00000   2.00000 :   24.00000

void gauss_jordan(int n, double A[N][N], double b[N])
n×n 行列 double A[N][N] とN次元ベクトル b[N] に対して Gauss-Jordan の掃き出し処理 (詳細は後述) を行う. ただし, 確認のため, 関数内では 1 行の掃き出しが終わる毎に途中経過を関数 matrix_vector_print を用いて次のように出力するようにせよ.
<0行目>
   1.0000   2.0000   3.0000 :   3.0000
   0.0000   2.0000  -2.0000 :   6.0000
   0.0000  -3.0000   6.0000 :   9.0000

<1行目>
   1.0000   0.0000   5.0000 :  -3.0000
   0.0000   1.0000  -1.0000 :   3.0000
   0.0000   0.0000   3.0000 :  18.0000

<2行目>
   1.0000   0.0000   0.0000 : -33.0000
   0.0000   1.0000   0.0000 :   9.0000
   0.0000   0.0000   1.0000 :   6.0000

jordan.c のプログラムは下記の通り.
jordan.c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "matrix.h"

int main (void)
{
  int n;
  double A[N][N];
  double b[N]; 
  double A_copy[N][N];
  double b_copy[N];
  double y[N];

  /* n の入力 */
  fprintf(stderr, "n = ");
  scanf("%d", &n);
  assert(n<=N);

  /* A と b の入力 */
  fprintf(stderr, "A = \n");
  matrix_scan(n, A);
  fprintf(stderr, "b = \n");
  vector_scan(n, b);
  printf("\n与えられた A と b\n");
  matrix_vector_print(n, A,b);

  /* A と b のコピーを残す */
  matrix_copy(n, A, A_copy);
  vector_copy(n, b, b_copy);

  /* ガウス・ジョルダンの掃き出し */
  gauss_jordan(n, A,b);
  /* A x = b の解 (x) が b に代入される */

  /* 解 x の表示 */
  printf("\n解 x \n");
  vector_print(n, b);

  /* 検算: 元のAと解の積が元の b と等しければ (Ax=bとなっていれば) OK */
  matrix_vector_prod(n, A_copy,b,y);
  printf("\nA x (与えられた b に等しければ OK)\n");
  vector_print(n, y);

  return 0;
}

次は, jordan.c と matrix.c をリンクして実行したときの出力例である.
与えられた A と b
   2.00000   4.00000   6.00000 :    6.00000
   3.00000   8.00000   7.00000 :   15.00000
   5.00000   7.00000  21.00000 :   24.00000

<0行目>
   1.00000   2.00000   3.00000 :    3.00000
   0.00000   2.00000  -2.00000 :    6.00000
   0.00000  -3.00000   6.00000 :    9.00000

<1行目>
   1.00000   0.00000   5.00000 :   -3.00000
   0.00000   1.00000  -1.00000 :    3.00000
   0.00000   0.00000   3.00000 :   18.00000

<2行目>
   1.00000   0.00000   0.00000 :  -33.00000
   0.00000   1.00000   0.00000 :    9.00000
   0.00000   0.00000   1.00000 :    6.00000

解 x 
 -33.00000
   9.00000
   6.00000

A x (与えられた b に等しければ OK)
   6.00000
  15.00000
  24.00000

「Gauss-Jordan の掃き出し」は次のような処理である.
次の3元連立一次方程式を例に考える．

   2x+4y+6z=6
   3x+8y+7z=15
   5x+7y+21z=24

x, y, z の係数をA[3][3], 定数値をb[3] で表す. 

   2  4  6  : 6 (0)
   3  8  7  :15 (1)
   5  7 21  :24 (2)

次の「規格化」と「掃き出し」作業を繰り返す. 

(0-1) (0)式を規格化(A[0][0] が1 になるように, (0) 式をA[0][0](=2) で割る)

   1  2  3  : 3 (0)/2
   3  8  7  :15 (1)
   5  7 21  :24 (2)

(0-2) (1) 式と(2) 式の掃き出し(A[1][0]=0, A[2][0]=0 となるように, 
それぞれ(1) と(2) から(0) のA[1][0](=3) 倍, A[2][0](=5) 倍を引く)

   1  2  3  : 3 (0)
   0  2 -2  : 6 (1)-(0)*3
   0 -3  6  : 9 (2)-(0)*5

(1-1) (1)式を規格化

   1  2  3  : 3 (0)
   0  1 -1  : 3 (1)/2
   0 -3  6  : 9 (2)

(1-2) (0) 式と(2) 式の掃き出し

   1  0  5  :-3 (0)-(1)*2
   0  1 -1  : 3 (1)
   0  0  3  :18 (2)+(1)*3


(2-1) (2)式を規格化

   1  0  5  :-3 (0)
   0  1 -1  : 3 (1)
   0  0  1  : 6 (2)/3

(2-2) (0) 式と(1) 式の掃き出し

   1  0  0  :-33 (0)-(2)*(5)
   0  1  0  :  9 (1)-(2)*(-1)
   0  0  1  :  6 (2)

この時点で，解(x=-33, y=9, z=6) がb[3]に入っている．
  
実行結果は以下のとおりである。
gatahayato@Gatas-MacBook-Pro O4 % gcc -Wall jordan.c matrix.c
gatahayato@Gatas-MacBook-Pro O4 % ./a.out < in.txt > out.txt
n = A = 
b = 

out.txtの内容は以下のとおりである。
与えられた A と b
   2.00000    4.00000    6.00000 :    6.00000
   3.00000    8.00000    7.00000 :   15.00000
   5.00000    7.00000   21.00000 :   24.00000
<0行目>
   1.00000    2.00000    3.00000 :    3.00000
   0.00000    2.00000   -2.00000 :    6.00000
   0.00000   -3.00000    6.00000 :    9.00000
<1行目>
   1.00000    0.00000    5.00000 :   -3.00000
   0.00000    1.00000   -1.00000 :    3.00000
   0.00000    0.00000    3.00000 :   18.00000
<2行目>
   1.00000    0.00000    0.00000 :  -33.00000
   0.00000    1.00000    0.00000 :    9.00000
   0.00000    0.00000    1.00000 :    6.00000

解 x 
 -33.00000
 9.00000
 6.00000

A x (与えられた b に等しければ OK)
 6.00000
 15.00000
 24.00000

Gauss-Jordan法を使ってn元連立一次方程式を得関数を作成することができた。
Gauss-Jordan法は線形代数の授業でやり方を勉強していたが、実際に実装する時に苦戦した。
結果的にforループを二つ使い、if (k != i)の条件ないでもう一度forループを使うことでうまく実装できた。

----------------------------------------
[課題4.2]

in.bmp の画像を反時計回りに 90 度回転したものを out.bmp に出力するプログラム image2rotate90.c を作成した。 (データ構造は image2.h のものを用いよ.)

実行結果は画像のため省略する

画像を九十度半時計回りに回転させることができた。コード内でforループを二重にし、その中で、
b->img[j][a->header.biHeight - 1 - i]:と書くことによって、取得したaの画素を90度回転した部分にコピーすることができた。
かなり時間がかかってしまったが、1/15までに作り切ることができたおでよかった。

----------------------------------------
[課題 O4 の感想]
今回の課題では配列と構造体について勉強することができた。久しぶりに構造体について触ったが、
各メンバーの取り扱いなど忘れてしまっていることが多くあった。この授業が終わっても、基本的な考え方や
アルゴリズムを覚えておくためにも、定期的にC言語に触る様にしていきたい。