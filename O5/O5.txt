科目名: プログラミング実習III
課題: O5
番号: 37022503
氏名: 山形 隼士
作成: 2023/1/15

----------------------------------------
[課題5.1]
C言語では, n が変数のときにサイズ n×n の2次元配列を動的に割り当てるのが難しいので, その代替として,

サイズ n*n の1次元配列を割り当て,
2次元配列の [i][j] 要素へのアクセスを, 1次元配列の [i*n+j] 要素へのアクセスに置き換える,
という手法が用いられることがある. この方法に基づいて, B4 の課題 (4-1) の matrix.c の動的割当て版 matrixd.c を作成した。

次の 5 つの関数のみ作成せよ.

double *matrixd_new(int n) … サイズ n*n の double 型 1 次元配列を割り当てて, その先頭要素へのポインタを返す.
void matrixd_delete(double *A)　… A の指す動的領域を解放する.
void matrixd_print(int n, double *A) … 課題 (4-1) (1) の matrix_print に相当するもの
void matrixd_scan(int n, double *A) … 課題 (4-1) (2) の matrix_scan に相当するもの
void matrixd_sum(int n, double *A, double *B, double *Y) … 課題 (4-1) (3) の matrix_sum に相当するもの
ヘッダファイル matrixd.h, テストプログラム matrixd3test.c, テストデータを以下に示す.

実行結果は以下のとおりである。
gatahayato@Gatas-MacBook-Pro O5 % gcc -Wall matrixd_main.c matrixd.c
gatahayato@Gatas-MacBook-Pro O5 % ./a.out < in.txt > out.txt
n = A
B
gatahayato@Gatas-MacBook-Pro O5 % diff -Bw out.txt exp.txt

out.txtの内容は以下のとおりである。
A
   3.25000    9.42000    7.34000    0.12000    5.98000 
   5.73000    7.11000    8.93000    6.32000    7.12000 
   8.23000    5.44000    3.12000    0.29000    4.23000 
   5.42000    6.22000    2.93000    4.32000    9.22000 
   7.13000    1.36000    9.34000    4.21000    4.31000 
B
   1.23000    0.34000    9.24000    6.24000    8.88000 
   2.59000    0.13000    3.19000    7.36000    6.35000 
   7.12000    9.44000    3.19000    0.25000    8.41000 
   3.42000    9.43000    4.23000    7.99000    8.43000 
   5.24000    0.23000    2.44000    9.34000    6.87000 
Y
   4.48000    9.76000   16.58000    6.36000   14.86000 
   8.32000    7.24000   12.12000   13.68000   13.47000 
  15.35000   14.88000    6.31000    0.54000   12.64000 
   8.84000   15.65000    7.16000   12.31000   17.65000 
  12.37000    1.59000   11.78000   13.55000   11.18000 


課題の条件通り、サイズ n*n の1次元配列を割り当て,
2次元配列の [i][j] 要素へのアクセスを, 1次元配列の [i*n+j] 要素へのアクセスに置き換える様にして(4-1)の課題を書き換えた。
5つともあまり難しくなかったが、mallocの書き方を忘れてしまっており、思い出すのに少し時間がかかった。

----------------------------------------
[課題5.2]
2次元配列を動的に割り当てる別の方法として, 下記のように 1 次元配列を指すポインタへの配列を用いる方法がある.


例えば, 上図で A[1] の指す 1 次元配列の第 2 要素へのアクセスは, A[1][2] と書くことができる. B4 の課題 (4-1) の matrix.c のこの方法に基づく動的割当て版 matrixdd.c を作成せよ.

オプション課題 (5-1) の 5 つの関数に相当する下記の関数を実装せよ.
double **matrixdd_new(int n)
void matrixdd_delete(int n, double **A)
void matrixdd_print(int n, double **A)
void matrixdd_scan(int n, double **A)
void matrixdd_sum(int n, double **A, double **B, double **Y)
関数 matrixdd_delete では, データの配列を全て解放した後にポインタの配列を解放する必要があることに留意せよ.

ヘッダファイル matrixdd.h, テストプログラム matrixdd3test.c を以下に示す. テストデータはオプション課題 (5-1) と同じである.

実行結果は、(5-1)と同様の結果のため、省略する

一次元配列を指すポインタの配列を定義することで、二次元配列を動的に割り当てることができた。
delete関数中にて、配列の要素全てをfreeしてからポインタの配列を開放することを忘れてしまっており、何回かエラーに遭遇した。
動的割り当ての方式も様々あると考えられるため、自分が勉強する言語に応じて覚えていきたい。

----------------------------------------
[課題 O5 の感想]
今回の課題では、動的割り当てについて復習した。今となってはあまりむずかすく感じない事柄だが、それは自分がこの内容をある程度理解できたからであると考える。
これから先の研究のためにも、残り少ない課題を丁寧に作成して、C言語の力をつけていきたい。